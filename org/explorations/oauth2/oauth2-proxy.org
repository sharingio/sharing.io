#+TITLE: OAuth2-Proxy

create a namespace.

#+begin_src shell
  kubectl create ns oauth2-proxy
#+end_src

#+RESULTS:
#+begin_example
namespace/oauth2-proxy created
#+end_example

create a secret for GitHub OAuth.

#+begin_src shell
  kubectl \
    -n oauth2-proxy \
    create secret generic oauth2-proxy \
      --from-literal=client-id= \
      --from-literal=client-secret= \
      --from-literal=cookie-secret="$(openssl rand -base64 16)"
#+end_src

#+RESULTS:
#+begin_example
secret/oauth2-proxy created
#+end_example

#+begin_src yaml :tangle oauth2-proxy.yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    labels:
      k8s-app: oauth2-proxy
    name: oauth2-proxy
  spec:
    replicas: 1
    selector:
      matchLabels:
        k8s-app: oauth2-proxy
    template:
      metadata:
        labels:
          k8s-app: oauth2-proxy
      spec:
        containers:
        - args:
          - --provider=github
          # - --github-org=kubernetes
          - --email-domain=*
          - --upstream=file:///dev/null
          - --http-address=0.0.0.0:4180
          # Register a new application
          # https://github.com/settings/applications/new
          env:
          - name: OAUTH2_PROXY_CLIENT_ID
            valueFrom:
              secretKeyRef:
                name: oauth2-proxy
                key: client-id
          - name: OAUTH2_PROXY_CLIENT_SECRET
            valueFrom:
              secretKeyRef:
                name: oauth2-proxy
                key: client-secret
          - name: OAUTH2_PROXY_COOKIE_SECRET
            valueFrom:
              secretKeyRef:
                name: oauth2-proxy
                key: cookie-secret
          image: quay.io/oauth2-proxy/oauth2-proxy:latest
          imagePullPolicy: Always
          name: oauth2-proxy
          ports:
          - containerPort: 4180
            protocol: TCP
  ---
  apiVersion: v1
  kind: Service
  metadata:
    labels:
      k8s-app: oauth2-proxy
    name: oauth2-proxy
  spec:
    ports:
    - name: http
      port: 4180
      protocol: TCP
      targetPort: 4180
    selector:
      k8s-app: oauth2-proxy
#+end_src

#+begin_src shell
  kubectl -n oauth2-proxy apply -f oauth2-proxy.yaml
#+end_src

#+RESULTS:
#+begin_example
deployment.apps/oauth2-proxy created
service/oauth2-proxy created
#+end_example

Install an Ingress manifest

#+begin_src yaml :tangle oauth2-proxy-ingress.yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: oauth2-proxy
  namespace: oauth2-proxy
spec:
  rules:
  - host: sharing.me.sharing.io
    http:
      paths:
      - backend:
          serviceName: oauth2-proxy
          servicePort: 4180
        path: /oauth2
#+end_src

#+begin_src shell
  kubectl -n oauth2-proxy apply -f oauth2-proxy-ingress.yaml
#+end_src

#+RESULTS:
#+begin_example
ingress.networking.k8s.io/oauth2-proxy created
#+end_example

* Getting Cookie secrets that were saved with OAuth2-Proxy in a separate app

Since the host remains the same and there is no policy against cookies on any route of the host, we're able to get the cookie.
Passing the same cookie secret to the new app, allows the email (and hopefully GitHub username) to be retrieved.

It is possible to get the username from a cookie, see
- https://github.com/oauth2-proxy/oauth2-proxy/blob/master/providers/github_test.go#L277

The session state can be revealed from a cookie, see
- https://github.com/oauth2-proxy/oauth2-proxy/blob/master/pkg/sessions/cookie/session_store.go#L52
- https://github.com/oauth2-proxy/oauth2-proxy/blob/a87beab1a06a439e0cb9a47d0000032d7eafa1e1/pkg/encryption/utils.go#L39

The latest oauth2-proxy module is located at
https://pkg.go.dev/github.com/oauth2-proxy/oauth2-proxy@v1.1.2-0.20200904143047-ef08d01b982f/pkg/apis/sessions

** Test cookie decryption

#+begin_src go :tangle sharingio-get-username-research-1.go
  package main

  import (
    "github.com/gorilla/mux"
    "log"
    "encoding/base64"
    "net/http"
    "time"
    "encoding/json"
    "strings"
    "os"
    "fmt"

    "github.com/oauth2-proxy/oauth2-proxy/pkg/apis/sessions"
    "github.com/oauth2-proxy/oauth2-proxy/pkg/encryption"
  )

  var (
    defaultOAuthCookieName = "_oauth2_proxy"
    maxCookieLength = 4000
  )

  // splitCookie reads the full cookie generated to store the session and splits
  // it into a slice of cookies which fit within the 4kb cookie limit indexing
  // the cookies from 0
  func splitCookie(c *http.Cookie) []*http.Cookie {
   if len(c.String()) < maxCookieLength {
    return []*http.Cookie{c}
   }

   log.Printf("WARNING: Multiple cookies are required for this session as it exceeds the 4kb cookie limit. Please use server side session storage (eg. Redis) instead.")

   cookies := []*http.Cookie{}
   valueBytes := []byte(c.Value)
   count := 0
   for len(valueBytes) > 0 {
    newCookie := copyCookie(c)
    newCookie.Name = splitCookieName(c.Name, count)
    count++

    newCookie.Value = string(valueBytes)
    cookieLength := len(newCookie.String())
    if cookieLength <= maxCookieLength {
     valueBytes = []byte{}
    } else {
     overflow := cookieLength - maxCookieLength
     valueSize := len(valueBytes) - overflow

     newValue := valueBytes[:valueSize]
     valueBytes = valueBytes[valueSize:]
     newCookie.Value = string(newValue)
    }
    cookies = append(cookies, newCookie)
   }
   return cookies
  }

  func splitCookieName(name string, count int) string {
   splitName := fmt.Sprintf("%s_%d", name, count)
   overflow := len(splitName) - 256
   if overflow > 0 {
    splitName = fmt.Sprintf("%s_%d", name[:len(name)-overflow], count)
   }
   return splitName
  }

  // loadCookie retreieves the sessions state cookie from the http request.
  // If a single cookie is present this will be returned, otherwise it attempts
  // to reconstruct a cookie split up by splitCookie
  func loadCookie(req *http.Request, cookieName string) (*http.Cookie, error) {
   c, err := req.Cookie(cookieName)
   if err == nil {
    return c, nil
   }
   cookies := []*http.Cookie{}
   err = nil
   count := 0
   for err == nil {
    var c *http.Cookie
    c, err = req.Cookie(splitCookieName(cookieName, count))
    if err == nil {
     cookies = append(cookies, c)
     count++
    }
   }
   if len(cookies) == 0 {
    return nil, fmt.Errorf("could not find cookie %s", cookieName)
   }
   return joinCookies(cookies)
  }

  // joinCookies takes a slice of cookies from the request and reconstructs the
  // full session cookie
  func joinCookies(cookies []*http.Cookie) (*http.Cookie, error) {
   if len(cookies) == 0 {
    return nil, fmt.Errorf("list of cookies must be > 0")
   }
   if len(cookies) == 1 {
    return cookies[0], nil
   }
   c := copyCookie(cookies[0])
   for i := 1; i < len(cookies); i++ {
    c.Value += cookies[i].Value
   }
   c.Name = strings.TrimRight(c.Name, "_0")
   return c, nil
  }

  func copyCookie(c *http.Cookie) *http.Cookie {
   return &http.Cookie{
    Name:       c.Name,
    Value:      c.Value,
    Path:       c.Path,
    Domain:     c.Domain,
    Expires:    c.Expires,
    RawExpires: c.RawExpires,
    MaxAge:     c.MaxAge,
    Secure:     c.Secure,
    HttpOnly:   c.HttpOnly,
    Raw:        c.Raw,
    Unparsed:   c.Unparsed,
    SameSite:   c.SameSite,
   }
  }

  // Logging ...
  // log the HTTP requests
  func Logging(next http.Handler) http.Handler {
    // log all requests
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
      jsonEncodedRequest, err := json.Marshal(r.Header)
      if (err != nil) {
        log.Panicln(err)
      }
      log.Printf("%v", string(jsonEncodedRequest))
      next.ServeHTTP(w, r)
    })
  }

  // Root ...
  // /api endpoint
  func Root(w http.ResponseWriter, r *http.Request) {
    authSecret := os.Getenv("APP_OAUTH2_SECRET")
    log.Printf("authSecret: %v\n", authSecret)

    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Headers logged"))
    cookie, err := loadCookie(r, defaultOAuthCookieName)
    if err != nil {
      // always http.ErrNoCookie
      fmt.Errorf("cookie %q not present", defaultOAuthCookieName)
      return
    }
    parts := strings.Split(cookie.Value, "|")
    log.Println(parts[0])
    value, err := base64.URLEncoding.DecodeString(parts[0])
    if err != nil {
      log.Printf("%#v\n", err)
      return
    }
    log.Printf("%#v\n", string(value))

    cipher, err := encryption.NewCFBCipher([]byte(authSecret))
    if err != nil {
      log.Printf("%#v\n", err)
      return
    }
    session, err := sessions.DecodeSessionState(value, cipher, true)
    if err != nil {
      log.Printf("%v\n", err)
	    return
    }
    log.Println(session.User)
  }

  func main() {
    port := ":8085"
    router := mux.NewRouter().StrictSlash(true)
    router.HandleFunc("/", Root)
    router.Use(Logging)
    srv := &http.Server{
      Handler:      router,
      Addr:         port,
      WriteTimeout: 15 * time.Second,
      ReadTimeout:  15 * time.Second,
    }
    log.Println("HTTP listening on", port)
    log.Fatal(srv.ListenAndServe())
  }
#+end_src

#+begin_src go :tangle sharingio-get-username-research-2.go
  package main

  import (
    "github.com/gorilla/mux"
    "log"
    "net/http"
    "time"
    "encoding/json"
    "os"

    "github.com/oauth2-proxy/oauth2-proxy/pkg/middleware"
    "github.com/oauth2-proxy/oauth2-proxy/pkg/sessions"
    oauth2options "github.com/oauth2-proxy/oauth2-proxy/pkg/apis/options"
    "github.com/justinas/alice"
  )

  // Logging ...
  // log the HTTP requests
  func Logging(next http.Handler) http.Handler {
    // log all requests
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
      jsonEncodedRequest, err := json.Marshal(r.Header)
      if err != nil {
        log.Panicln(err)
      }
      log.Printf("%v", string(jsonEncodedRequest))
      next.ServeHTTP(w, r)
    })
  }

  // Root ...
  // /api endpoint
  func Root(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Headers logged"))
  }

  func main() {
    port := ":8085"
    router := mux.NewRouter().StrictSlash(true)
    router.HandleFunc("/", Root)

    authSecret := os.Getenv("APP_OAUTH2_SECRET")
    log.Printf("authSecret: %v\n", authSecret)
    cookieOptions := oauth2options.Cookie{
      Name: "_oauth2_proxy",
      Secret: authSecret,
    }
    sessionOptions := oauth2options.SessionOptions{
      Type: oauth2options.CookieSessionStoreType,
    }
    sessionStore, err := sessions.NewSessionStore(&sessionOptions, &cookieOptions)
    if err != nil {
      log.Println(err)
      return
    }
    storedSessionOptions := middleware.StoredSessionLoaderOptions{
      SessionStore: sessionStore,
    }
    chain := alice.New()
    chain = chain.Append(Logging, middleware.NewScope(), middleware.NewStoredSessionLoader(&storedSessionOptions))

    srv := &http.Server{
      Handler:      chain.Then(router),
      Addr:         port,
      WriteTimeout: 15 * time.Second,
      ReadTimeout:  15 * time.Second,
    }
    log.Println("HTTP listening on", port)
    log.Fatal(srv.ListenAndServe())
  }
#+end_src


Create a Kubernetes Service resource into Humacs, to route traffic to the program above
#+begin_src yaml :tangle sharingio-get-username-service.yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: sharingio-get-username
  spec:
    ports:
    - name: http
      port: 8085
      protocol: TCP
      targetPort: 8085
    selector:
      app.kubernetes.io/instance: me-humacs
#+end_src

Create an Ingress mapping
#+begin_src yaml :tangle sharingio-get-username-ingress.yaml
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: sharingio-get-username
spec:
  rules:
  - host: sharing.me.sharing.io
    http:
      paths:
      - backend:
          serviceName: sharingio-get-username
          servicePort: 8085
        path: /
#+end_src

#+begin_src shell
  kubectl -n me-humacs apply -f sharingio-get-username-service.yaml -f sharingio-get-username-ingress.yaml
#+end_src

#+RESULTS:
#+begin_example
service/sharingio-get-username created
ingress.networking.k8s.io/sharingio-get-username created
#+end_example

When running, make sure that there's an env var =APP_OAUTH2_SECRET=, that's set to the output of

#+begin_src shell
  kubectl -n oauth2-proxy get secret oauth2-proxy -o=jsonpath='{.data.cookie\-secret}' | base64 -d ; echo
#+end_src
